/**
 * Image utilities for handling image uploads, processing, and caching
 */

// Image cache interface
export interface CachedImage {
  id: string;
  originalFile?: File;
  dataUrl: string;
  thumbnail: string;
  uploadedAt: Date;
  persona: string;
  description?: string;
  tags?: string[];
  aiGenerated?: boolean; // Whether the description was generated by AI
}

// Defensive: handle historical cases where description was stored as an object
type DescriptionLike = unknown;

function stringifyDescription(desc: DescriptionLike): string {
  try {
    if (desc == null) return '';
    if (typeof desc === 'string') return desc;
    if (typeof desc === 'number' || typeof desc === 'boolean')
      return String(desc);
    if (Array.isArray(desc))
      return desc.map(v => stringifyDescription(v)).join(', ');
    if (typeof desc === 'object') {
      const obj = desc as Record<string, unknown>;
      // If it looks like our AI analysis structure, format key parts nicely
      const knownKeys = [
        'objects',
        'people',
        'setting',
        'colors',
        'mood',
        'text_visible',
      ];
      const parts: string[] = [];
      for (const key of knownKeys) {
        if (obj[key] !== undefined) {
          const val = obj[key];
          const text = Array.isArray(val)
            ? val.map(v => stringifyDescription(v)).join(', ')
            : stringifyDescription(val);
          if (text) parts.push(`${key}: ${text}`);
        }
      }
      if (parts.length) return parts.join(' | ');
      // Fallback to a compact JSON string
      return JSON.stringify(desc);
    }
    return '';
  } catch {
    return '';
  }
}

// Image processing options
export interface ImageProcessingOptions {
  maxWidth?: number;
  maxHeight?: number;
  quality?: number;
  format?: 'jpeg' | 'png' | 'webp';
}

/**
 * Convert a file to a data URL (base64)
 */
export const fileToDataUrl = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsDataURL(file);
  });
};

/**
 * Resize and compress an image
 */
export const processImage = (
  file: File,
  options: ImageProcessingOptions = {}
): Promise<string> => {
  return new Promise((resolve, reject) => {
    const {
      maxWidth = 1024,
      maxHeight = 1024,
      quality = 0.8,
      format = 'jpeg',
    } = options;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    img.onload = () => {
      // Calculate new dimensions
      let { width, height } = img;

      if (width > maxWidth || height > maxHeight) {
        const ratio = Math.min(maxWidth / width, maxHeight / height);
        width *= ratio;
        height *= ratio;
      }

      // Set canvas dimensions
      canvas.width = width;
      canvas.height = height;

      // Draw and compress image
      ctx?.drawImage(img, 0, 0, width, height);

      const dataUrl = canvas.toDataURL(`image/${format}`, quality);
      resolve(dataUrl);
    };

    img.onerror = () => reject(new Error('Failed to load image'));

    // Load the image
    fileToDataUrl(file)
      .then(dataUrl => {
        img.src = dataUrl;
      })
      .catch(reject);
  });
};

/**
 * Create a thumbnail from an image
 */
export const createThumbnail = (
  file: File,
  size: number = 150
): Promise<string> => {
  return processImage(file, {
    maxWidth: size,
    maxHeight: size,
    quality: 0.7,
    format: 'jpeg',
  });
};

/**
 * Validate image file
 */
export const validateImageFile = (
  file: File
): { valid: boolean; error?: string } => {
  // Check file type
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (!allowedTypes.includes(file.type)) {
    return {
      valid: false,
      error: 'Invalid file type. Please upload JPEG, PNG, GIF, or WebP images.',
    };
  }

  // Check file size (10MB limit)
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    return {
      valid: false,
      error: 'File too large. Please upload images smaller than 10MB.',
    };
  }

  return { valid: true };
};

/**
 * Save image to cache with AI-generated description
 */
export const saveImageToCache = async (
  file: File,
  persona: string,
  userDescription?: string,
  tags?: string[]
): Promise<CachedImage> => {
  const id = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  // Compress original image and create thumbnail to reduce localStorage usage
  const [compressedDataUrl, thumbnail] = await Promise.all([
    processImage(file, {
      maxWidth: 1280,
      maxHeight: 1280,
      quality: 0.7,
      format: 'jpeg',
    }),
    createThumbnail(file, 150),
  ]);

  // Initial save with placeholder description
  const cachedImage: CachedImage = {
    id,
    originalFile: file,
    dataUrl: compressedDataUrl,
    thumbnail,
    uploadedAt: new Date(),
    persona,
    description:
      userDescription ||
      `Image uploaded by ${persona} at ${new Date().toLocaleString()}`,
    tags,
    aiGenerated: false,
  };

  // Save to localStorage immediately
  const cacheKey = 'alterEgo_imageCache';
  const existingCache = getImageCache();
  existingCache.push(cachedImage);

  // Keep only lightweight metadata in localStorage (no base64 blobs)
  const metadataToStore = existingCache.map(img => ({
    id: img.id,
    uploadedAt: img.uploadedAt,
    persona: img.persona,
    description: stringifyDescription((img as any).description),
    tags: img.tags,
    aiGenerated: img.aiGenerated,
  }));

  setItemWithEviction(cacheKey, JSON.stringify(metadataToStore));

  // Store the actual image data separately
  setItemWithEviction(`alterEgo_image_${id}`, compressedDataUrl);
  setItemWithEviction(`alterEgo_thumb_${id}`, thumbnail);

  return cachedImage;
};

/**
 * Update cached image with AI-generated description
 */
export const updateCachedImageDescription = (
  id: string,
  aiDescription: string,
  extractedTags?: string[]
): void => {
  try {
    const cache = getImageCache();
    const imageIndex = cache.findIndex(img => img.id === id);

    if (imageIndex === -1) return;

    // Update the image with AI description
    cache[imageIndex] = {
      ...cache[imageIndex],
      description: aiDescription,
      tags: extractedTags || cache[imageIndex].tags,
      aiGenerated: true,
    };

    // Save updated cache with lightweight metadata only
    const metadataToStore = cache.map(img => ({
      id: img.id,
      uploadedAt: img.uploadedAt,
      persona: img.persona,
      description: stringifyDescription((img as any).description),
      tags: img.tags,
      aiGenerated: img.aiGenerated,
    }));

    setItemWithEviction('alterEgo_imageCache', JSON.stringify(metadataToStore));
  } catch (error) {
    console.error('Error updating cached image description:', error);
  }
};

/**
 * Get all cached images
 */
export const getImageCache = (): CachedImage[] => {
  try {
    const cacheKey = 'alterEgo_imageCache';
    const cache = localStorage.getItem(cacheKey);
    if (!cache) return [];

    const metadata: CachedImage[] = JSON.parse(cache);

    // Reconstruct full objects with image data and normalize description
    return metadata.map(meta => {
      const normalizedDescription = stringifyDescription(
        (meta as any).description
      );
      return {
        ...meta,
        description: normalizedDescription,
        uploadedAt: new Date(meta.uploadedAt),
        dataUrl: localStorage.getItem(`alterEgo_image_${meta.id}`) || '',
        thumbnail: localStorage.getItem(`alterEgo_thumb_${meta.id}`) || '',
      } as CachedImage;
    });
  } catch (error) {
    console.error('Error loading image cache:', error);
    return [];
  }
};

/**
 * Get cached image by ID
 */
export const getCachedImage = (id: string): CachedImage | null => {
  const cache = getImageCache();
  return cache.find(img => img.id === id) || null;
};

/**
 * Search cached images
 */
export const searchCachedImages = (
  query: string,
  persona?: string
): CachedImage[] => {
  const cache = getImageCache();
  const lowerQuery = query.toLowerCase();

  return cache.filter(img => {
    // Filter by persona if specified
    if (persona && img.persona !== persona) return false;

    // Search in description and tags
    const descText = stringifyDescription(
      (img as any).description
    ).toLowerCase();
    const matchesDescription = descText.includes(lowerQuery);
    const matchesTags = img.tags?.some(tag =>
      tag.toLowerCase().includes(lowerQuery)
    );

    return matchesDescription || matchesTags;
  });
};

/**
 * Delete cached image
 */
export const deleteCachedImage = (id: string): void => {
  try {
    // Remove from cache
    const cache = getImageCache().filter(img => img.id !== id);
    const metadataToStore = cache.map(img => ({
      id: img.id,
      uploadedAt: img.uploadedAt,
      persona: img.persona,
      description: stringifyDescription((img as any).description),
      tags: img.tags,
      aiGenerated: img.aiGenerated,
    }));

    setItemWithEviction('alterEgo_imageCache', JSON.stringify(metadataToStore));

    // Remove image data
    localStorage.removeItem(`alterEgo_image_${id}`);
    localStorage.removeItem(`alterEgo_thumb_${id}`);
  } catch (error) {
    console.error('Error deleting cached image:', error);
  }
};

/**
 * Attempt to write to localStorage; if quota exceeded, evict oldest images until it succeeds.
 */
function setItemWithEviction(key: string, value: string): void {
  try {
    localStorage.setItem(key, value);
  } catch (e) {
    // Quota likely exceeded â€” progressively evict oldest images
    let attempts = 0;
    while (attempts < 10) {
      const evicted = evictOldestImage();
      if (!evicted) break;
      attempts++;
      try {
        localStorage.setItem(key, value);
        return;
      } catch {
        // keep evicting
      }
    }
    throw e;
  }
}

/**
 * Remove the oldest image from the cache to free up space.
 * Returns true if something was evicted.
 */
function evictOldestImage(): boolean {
  try {
    const cache = getImageCache();
    if (cache.length === 0) return false;
    const sorted = [...cache].sort(
      (a, b) => a.uploadedAt.getTime() - b.uploadedAt.getTime()
    );
    const oldest = sorted[0];
    // Update cache metadata and remove blobs
    const remaining = cache.filter(img => img.id !== oldest.id);
    const metadataToStore = remaining.map(img => ({
      id: img.id,
      uploadedAt: img.uploadedAt,
      persona: img.persona,
      description: stringifyDescription((img as any).description),
      tags: img.tags,
      aiGenerated: img.aiGenerated,
    }));
    try {
      localStorage.setItem(
        'alterEgo_imageCache',
        JSON.stringify(metadataToStore)
      );
    } catch {
      // If even metadata fails (very unlikely as it's small), clear all
      localStorage.removeItem('alterEgo_imageCache');
    }
    localStorage.removeItem(`alterEgo_image_${oldest.id}`);
    localStorage.removeItem(`alterEgo_thumb_${oldest.id}`);
    return true;
  } catch (err) {
    console.error('Failed to evict oldest image:', err);
    return false;
  }
}

/**
 * Clear all cached images
 */
export const clearImageCache = (): void => {
  try {
    const cache = getImageCache();

    // Remove all image data
    cache.forEach(img => {
      localStorage.removeItem(`alterEgo_image_${img.id}`);
      localStorage.removeItem(`alterEgo_thumb_${img.id}`);
    });

    // Clear cache metadata
    localStorage.removeItem('alterEgo_imageCache');
  } catch (error) {
    console.error('Error clearing image cache:', error);
  }
};

/**
 * Get cache size in bytes
 */
export const getImageCacheSize = (): number => {
  try {
    const cache = getImageCache();
    let totalSize = 0;

    cache.forEach(img => {
      const imageData = localStorage.getItem(`alterEgo_image_${img.id}`);
      const thumbData = localStorage.getItem(`alterEgo_thumb_${img.id}`);

      if (imageData) totalSize += imageData.length;
      if (thumbData) totalSize += thumbData.length;
    });

    return totalSize;
  } catch (error) {
    console.error('Error calculating cache size:', error);
    return 0;
  }
};

/**
 * Format cache size for display
 */
export const formatCacheSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

/**
 * Open an image in a new tab with proper handling for data URLs
 */
export const openImageInNewTab = (imageUrl: string): void => {
  try {
    // Check if it's a data URL
    if (imageUrl.startsWith('data:')) {
      // Create a blob URL for better browser compatibility
      const byteCharacters = atob(imageUrl.split(',')[1]);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);

      // Extract MIME type from data URL
      const mimeMatch = imageUrl.match(/data:([^;]+)/);
      const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';

      const blob = new Blob([byteArray], { type: mimeType });
      const blobUrl = URL.createObjectURL(blob);

      // Open in new tab with blob URL
      const newWindow = window.open(blobUrl, '_blank');

      // Clean up the blob URL after a delay to prevent memory leaks
      if (newWindow) {
        setTimeout(() => {
          URL.revokeObjectURL(blobUrl);
        }, 1000);
      } else {
        // If popup was blocked, clean up immediately
        URL.revokeObjectURL(blobUrl);
        alert(
          'Popup blocked. Please allow popups for this site to view images in full size.'
        );
      }
    } else {
      // Regular URL, open directly
      window.open(imageUrl, '_blank');
    }
  } catch (error) {
    console.error('Error opening image:', error);
    // Fallback: try direct URL
    window.open(imageUrl, '_blank');
  }
};
